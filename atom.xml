<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yjp的个人小窝</title>
  
  
  <link href="https://yjpwzy1314.com/atom.xml" rel="self"/>
  
  <link href="https://yjpwzy1314.com/"/>
  <updated>2022-12-10T05:15:53.364Z</updated>
  <id>https://yjpwzy1314.com/</id>
  
  <author>
    <name>yjp</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图形学-离线渲染器Y-PBR</title>
    <link href="https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%A6%BB%E7%BA%BF%E6%B8%B2%E6%9F%93%E5%99%A8Y-PBR/"/>
    <id>https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E7%A6%BB%E7%BA%BF%E6%B8%B2%E6%9F%93%E5%99%A8Y-PBR/</id>
    <published>2022-12-10T05:15:13.000Z</published>
    <updated>2022-12-10T05:15:53.364Z</updated>
    
    
    
    
    <category term="图形学" scheme="https://yjpwzy1314.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>图形学-双向路径追踪</title>
    <link href="https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%8C%E5%90%91%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"/>
    <id>https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%8C%E5%90%91%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/</id>
    <published>2022-12-10T05:15:03.000Z</published>
    <updated>2022-12-10T05:15:55.393Z</updated>
    
    
    
    
    <category term="图形学" scheme="https://yjpwzy1314.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>图形学-随机渐进式光子映射</title>
    <link href="https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E9%9A%8F%E6%9C%BA%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%85%89%E5%AD%90%E6%98%A0%E5%B0%84/"/>
    <id>https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E9%9A%8F%E6%9C%BA%E6%B8%90%E8%BF%9B%E5%BC%8F%E5%85%89%E5%AD%90%E6%98%A0%E5%B0%84/</id>
    <published>2022-12-10T05:14:51.000Z</published>
    <updated>2022-12-10T05:15:56.200Z</updated>
    
    
    
    
    <category term="图形学" scheme="https://yjpwzy1314.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>图形学-参与介质</title>
    <link href="https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/"/>
    <id>https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E5%8F%82%E4%B8%8E%E4%BB%8B%E8%B4%A8/</id>
    <published>2022-12-10T05:14:39.000Z</published>
    <updated>2022-12-10T05:15:50.285Z</updated>
    
    
    
    
    <category term="图形学" scheme="https://yjpwzy1314.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>图形学-次表面散射</title>
    <link href="https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%AC%A1%E8%A1%A8%E9%9D%A2%E6%95%A3%E5%B0%84/"/>
    <id>https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%AC%A1%E8%A1%A8%E9%9D%A2%E6%95%A3%E5%B0%84/</id>
    <published>2022-12-10T05:14:25.000Z</published>
    <updated>2022-12-10T05:15:51.756Z</updated>
    
    
    
    
    <category term="图形学" scheme="https://yjpwzy1314.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>毛发渲染</title>
    <link href="https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/"/>
    <id>https://yjpwzy1314.com/2022/12/10/%E5%9B%BE%E5%BD%A2%E5%AD%A6-%E6%AF%9B%E5%8F%91%E6%B8%B2%E6%9F%93/</id>
    <published>2022-12-10T05:13:07.000Z</published>
    <updated>2022-12-10T05:39:42.701Z</updated>
    
    <content type="html"><![CDATA[<p>&#x2F;&#x2F;todo</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&amp;#x2F;&amp;#x2F;todo&lt;/p&gt;
</summary>
      
    
    
    
    <category term="图形学" scheme="https://yjpwzy1314.com/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>printCycles</title>
    <link href="https://yjpwzy1314.com/2020/12/28/printCycles/"/>
    <id>https://yjpwzy1314.com/2020/12/28/printCycles/</id>
    <published>2020-12-28T15:53:52.000Z</published>
    <updated>2021-06-11T02:53:30.336Z</updated>
    
    <content type="html"><![CDATA[<p>问题描述很简单：判断图中是否有环路，如果有环路，打印出来。</p><p>我采用深度优先搜索的方式来解决这个问题。</p><p><strong>解题思路</strong></p><p>从图的第一个顶点开始搜索，用一个数组path记录已经搜索过的节点。同时用一个数组vis记录节点是否已经访问过。 当我们搜索时，我们用vis来判断当前节点是否访问过，如果访问过，我们就发现了一个环路（因为之前我们已经到过这个节点，现在又到这个节点了，说明就这个路就是一个环） 这个时候我们退出循环，把之前访问到的这个节点到第二次访问到这个节点的中所有的节点都打印出来。就是一个环。同时我们要用一个int值n来记录当前是搜索路径上的第几个节点</p><p>我们来简单地看个例子。</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/graph.jpg" alt="graph"></p><p>下一个搜索的节点为节点1，path为{0,1}</p><p>节点1搜索的第一个节点为2，节点2搜索的第一个节点为3，节点3搜索的第一个节点为0，搜索到0的时候我们发现0我们好像已经访问过了，于是乎就找到了一个环，此时path为{0，1，2，3，0}，然后返回。这个时候深搜返回到节点3（因为节点3要搜节点0和节点4，节点1），节点3依次搜索节点4，0，搜索到0的时候我们发现这又是一个环路。path为{0,1,2,3,4,0},打印，</p><p>从节点3返回至节点2，节点2只有节点3要搜，所以返回到节点1.节点1继续搜至节点3，此时path为{0,1,3}节点3先搜索至节点0,path为{0,1,3,0};打印后返回</p><p>搜索节点4至节点0 path为{0,1,3,4,0};</p><p>最终所有环路为</p><p>0 1 2 3 0；0 1 2 3 4 0； 0 1 3 0；0 1 3 4 0；</p><p>贴个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class Graph &#123;</span><br><span class="line">    class vetrx&#123;</span><br><span class="line">        int id;</span><br><span class="line">        int val;</span><br><span class="line">        public  vetrx()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        public vetrx(int i, int i1) &#123;</span><br><span class="line">            this.id=i;</span><br><span class="line">            this.val=i1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vetrx[] vetrxs;</span><br><span class="line">    int vnum;</span><br><span class="line">    HashMap&lt;vetrx ,LinkedList&lt;vetrx&gt;&gt; graph=new HashMap&lt;&gt;();</span><br><span class="line">    int[][] w;</span><br><span class="line">    HashMap&lt;vetrx,Integer&gt; Dijkstra(vetrx v)&#123;</span><br><span class="line">        HashMap&lt;vetrx,Integer&gt; ans=new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        return  null;</span><br><span class="line">    &#125;</span><br><span class="line">    public  Graph(int[] vet,int[][] gra)&#123;</span><br><span class="line">        this.vnum=vet.length;</span><br><span class="line">        this.vetrxs=new vetrx[vnum];</span><br><span class="line">        for(int i=0;i&lt;vnum;i++)</span><br><span class="line">        &#123;   vetrxs[i]=new vetrx(i,vet[i]); &#125;</span><br><span class="line">        for(int i=0;i&lt;vnum;i++)&#123;</span><br><span class="line">            LinkedList&lt;vetrx&gt; vs=new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for(int j=0;j&lt;vnum;j++)&#123;</span><br><span class="line">               if(gra[i][j]!=0)</span><br><span class="line">                   vs.add(vetrxs[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            graph.put(vetrxs[i],vs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;vetrx&gt; path=new LinkedList();</span><br><span class="line">    void dfs(vetrx v,int n , boolean[] vis)&#123;</span><br><span class="line">        if(n==vnum+2)</span><br><span class="line">            return;</span><br><span class="line">        path.set(n,v);</span><br><span class="line">        if(vis[v.id])&#123;</span><br><span class="line">            int first=path.indexOf(v);</span><br><span class="line">            for(int i=first;i&lt;=n;i++)</span><br><span class="line">                System.out.print(path.get(i).id);</span><br><span class="line">            System.out.println();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v.id]=true;</span><br><span class="line">        for(vetrx nxt:graph.get(v))</span><br><span class="line">            dfs(nxt,n+1,vis);</span><br><span class="line">        vis[v.id]=false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void printallthecycle()&#123;</span><br><span class="line">        for(int i=0;i&lt;vnum+2;i++)</span><br><span class="line">           path.add(new vetrx());</span><br><span class="line">        LinkedList&lt;vetrx&gt; p=new LinkedList&lt;&gt;();</span><br><span class="line">        boolean vis[] =new boolean[vnum];</span><br><span class="line">        p.add(vetrxs[0]);</span><br><span class="line">        dfs(vetrxs[0],1,vis);</span><br><span class="line"></span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>graph类有个构造函数 第一个数组用来说明图节点的val，第二个数组用来说明节点之间边的关系。这个类的边关系用hashmap存储。</p><p>这边有一个函数用来测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import ADT.Graph;</span><br><span class="line">import ADT.Tree;</span><br><span class="line">import ADT.node;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">import static org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line">public class Graphtest &#123;</span><br><span class="line">    PrintStream oldPrintStream = System.out; //将原来的System.out交给printStream 对象保存</span><br><span class="line">    ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">    @Before</span><br><span class="line">   public void init()&#123;</span><br><span class="line"></span><br><span class="line">       System.setOut(new PrintStream(bos));</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public  void printcycletest1()</span><br><span class="line">    &#123; int[] vrtexs=&#123;1,2,3,4,5,6,7,8&#125;;</span><br><span class="line">        int[][] gra=new int[8][8];</span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">            gra[i][i+1]=1;</span><br><span class="line">        gra[4][1]=1;</span><br><span class="line">        gra[1][1]=1;</span><br><span class="line">        gra[3][5]=1;</span><br><span class="line">        gra[5][6]=1;</span><br><span class="line">        gra[6][7]=1;</span><br><span class="line">        gra[7][5]=1;</span><br><span class="line">        Graph graph=new Graph(vrtexs,gra);</span><br><span class="line">        graph.printallthecycle();</span><br><span class="line">        assertEquals(bos.toString(),&quot;11\n&quot; +</span><br><span class="line">                &quot;12341\n&quot; +</span><br><span class="line">                &quot;5675\n&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public  void printcycletest2()&#123;</span><br><span class="line">        int[] vrtexs=&#123;0,1,2,3,4&#125;;</span><br><span class="line">        int [][] gra=new int[5][5];</span><br><span class="line">        gra[0][1]=1;</span><br><span class="line">        gra[1][2]=1; gra[1][3]=1;gra[2][3]=1;gra[3][0]=1;</span><br><span class="line">        gra[3][4]=1;gra[4][0]=1;</span><br><span class="line">        Graph graph=new Graph(vrtexs,gra);</span><br><span class="line">        graph.printallthecycle();</span><br><span class="line">        assertEquals(bos.toString(),&quot;01230\n&quot; +</span><br><span class="line">                &quot;012340\n&quot; +</span><br><span class="line">                &quot;0130\n&quot; +</span><br><span class="line">                &quot;01340\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么多，希望老婆大大看完如果有不懂的可以马上来问我（这篇博客是因为老婆因为这个算法心情不好所以写的555）老婆心情不好俺自己心情也不好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题描述很简单：判断图中是否有环路，如果有环路，打印出来。&lt;/p&gt;
&lt;p&gt;我采用深度优先搜索的方式来解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从图的第一个顶点开始搜索，用一个数组path记录已经搜索过的节点。同时用一个数组vis</summary>
      
    
    
    
    <category term="算法" scheme="https://yjpwzy1314.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>avltree</title>
    <link href="https://yjpwzy1314.com/2020/12/21/avltree/"/>
    <id>https://yjpwzy1314.com/2020/12/21/avltree/</id>
    <published>2020-12-21T03:53:21.000Z</published>
    <updated>2021-06-02T06:51:29.782Z</updated>
    
    <content type="html"><![CDATA[<p>二叉平衡搜索树（avl树）满足以下定义：</p><p> 1：为二叉搜索树</p><p> 2：左子树与右子树高度差不超过1</p><p> 3: 左右子树均为avl树</p><p>主要实现了插入和删除操作</p><p>我们每个节点用一个int值记录当前节点的高度，叶子结点高度为1。</p><p>我们引入平衡因子的概念（BalancedFactor）来帮助恢复平衡。</p><p>插入操作：利用二叉搜索树的性质找到待插入的位置</p><p>插入后需要检查树是否平衡。</p><p>不平衡的可能情况有四种</p><p>LL，LR，RL，RR（其实这里应该有图然后来分析的，但是我目前没找到什么好用的工具x，以后再补上吧）</p><p>LL：右旋即可</p><p>LR：对当前节点的左子节点左旋变为LL情况，然后右旋即可</p><p>RR：左旋</p><p>RL：当前节点的右子节点右旋变为RR情况，然后左旋即可</p><p>左旋和右旋的操作。俺就不多赘述了 ，网上比较多。</p><p>删除操作：</p><p> 如果要删除的节点不存在直接返回即可。</p><p> 如果要删除的节点是叶子结点。直接删除。</p><p> 如果要删除的节点只有一个子节点。用该子节点替换要删除的节点即可。</p><p> 如果要删除的节点有两个子节点。找到该节点的右子树的最小节点。用该节点的值替换待删除节点的值。递归地在右子树删除最小节点（递归到删除叶子结点的情况）</p><p>在每次删除操作完成后，更新节点高度，并检查avl树是否需要调整。</p><p>avl树 java实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">import  java.util.Queue;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class avlTree &#123;</span><br><span class="line">    private  class Node&#123;</span><br><span class="line">        Node(int val)&#123;</span><br><span class="line">            this.val=val;</span><br><span class="line">            this.height=1;</span><br><span class="line">        &#125;</span><br><span class="line">        int val;</span><br><span class="line">        Node left;</span><br><span class="line">        Node  right;</span><br><span class="line">        int height;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root;</span><br><span class="line">    void del(int val)&#123;</span><br><span class="line">        this.root=del(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    void  insert(int val)&#123;</span><br><span class="line">        this.root=insert(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    void updateheight(Node t)&#123;</span><br><span class="line">        t.height=Math.max(getheight(t.left),getheight(t.right))+1;</span><br><span class="line">    &#125;</span><br><span class="line">    Node insert(Node root,int val)&#123;</span><br><span class="line">        Node newnode=new Node(val);</span><br><span class="line">        if(root==null)</span><br><span class="line">            return newnode;</span><br><span class="line">        if(val&gt;root.val)</span><br><span class="line">            root.right=insert(root.right,val);</span><br><span class="line">        else</span><br><span class="line">            root.left=insert(root.left,val);</span><br><span class="line">        updateheight(root);</span><br><span class="line">        int balfactor=getBalancedFactor(root);</span><br><span class="line">        int lbalfactor=getBalancedFactor(root.left);</span><br><span class="line">        int rbalfactor=getBalancedFactor(root.right);</span><br><span class="line">        if(balfactor&gt;1 &amp;&amp; lbalfactor&gt;=0)</span><br><span class="line">            return  rroate(root); //LL情况 进行右旋</span><br><span class="line">        if(balfactor&gt;1 &amp;&amp; lbalfactor&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            root.left=lroate(root.left);</span><br><span class="line">            return  rroate(root); //先左旋变成lr 再右旋</span><br><span class="line">        &#125;</span><br><span class="line">        if(balfactor&lt;-1 &amp;&amp; rbalfactor&lt;0)</span><br><span class="line">            return  lroate(root); //rr</span><br><span class="line">       if(balfactor&lt;-1 &amp;&amp; rbalfactor&gt;=0)</span><br><span class="line">       &#123;</span><br><span class="line">           root.right=rroate(root.right);</span><br><span class="line">           return  lroate(root);</span><br><span class="line">       &#125;</span><br><span class="line">       return  root;</span><br><span class="line">    &#125;</span><br><span class="line">    Node lroate(Node  y)&#123;  // 左旋</span><br><span class="line">        Node  x=y.right;</span><br><span class="line">        Node  temp=x.left;</span><br><span class="line">        x.left=y;</span><br><span class="line">        y.right=temp;</span><br><span class="line">        updateheight(y);</span><br><span class="line">        updateheight(x);</span><br><span class="line">        return  x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node rroate(Node y)&#123;</span><br><span class="line">        Node x=y.left;</span><br><span class="line">        Node temp=x.right;</span><br><span class="line">        x.right=y;</span><br><span class="line">        y.left=temp;</span><br><span class="line">        updateheight(y);</span><br><span class="line">        updateheight(x);</span><br><span class="line">        return  x;</span><br><span class="line">    &#125;</span><br><span class="line">    void pr()&#123;</span><br><span class="line">        Queue&lt;Node&gt; q=new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        int curheight=getheight(root);</span><br><span class="line">        while(q.size()&gt;0)&#123;</span><br><span class="line">            Node t=q.poll();</span><br><span class="line">            if(t.height!=curheight)&#123;</span><br><span class="line">                curheight--;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(t.val+&quot;  &quot;);</span><br><span class="line">            if(t.left!=null) q.add(t.left);</span><br><span class="line">            if(t.right!=null) q.add(t.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public      int getheight(Node node)&#123;</span><br><span class="line">        if(node==null) return  0; return  node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  int getBalancedFactor(Node node)&#123;</span><br><span class="line"></span><br><span class="line">        return  node==null?0:getheight(node.left)-getheight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  boolean isBST(Node rt)&#123;</span><br><span class="line">        if(rt==null) return  true;</span><br><span class="line">        if(rt.left==null &amp;&amp; rt.right==null) return  true;</span><br><span class="line">        if(rt.left==null)</span><br><span class="line">            return  rt.right.val&gt;rt.val &amp;&amp; isBST(rt.right);</span><br><span class="line">        if(rt.right==null)</span><br><span class="line">            return  rt.left.val&lt;rt.val &amp;&amp; isBST(rt.left);</span><br><span class="line">        return  rt.left.val&lt;rt.val &amp;&amp; rt.right.val&gt;rt.val &amp;&amp; isBST(rt.left) &amp;&amp; isBST(rt.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Node  del(Node t,int val)&#123;</span><br><span class="line">            if(t==null) return null;  //val 不存在</span><br><span class="line">            if(t.val==val)</span><br><span class="line">            &#123;</span><br><span class="line">                if(t.left==null &amp;&amp; t.right==null) return  null;</span><br><span class="line">                else if(t.left==null)  t=t.right;</span><br><span class="line">                else if(t.right==null) t=t.left;</span><br><span class="line">                else &#123;    //左右子树均不为空</span><br><span class="line">                    Node tar=t.right;</span><br><span class="line">                    while(tar.left!=null)</span><br><span class="line">                        tar=tar.left;</span><br><span class="line">                    t.val=tar.val;</span><br><span class="line">                    t.right=del(t.right,t.val); //</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(val&gt;t.val)</span><br><span class="line">                t.right=del(t.right,t.val);</span><br><span class="line">            if(val&lt;t.val)</span><br><span class="line">                t.left=del(t.left,t.val);</span><br><span class="line">            updateheight(t);</span><br><span class="line">            int balfactor=getBalancedFactor(t);</span><br><span class="line">            int lbalfactor=getBalancedFactor(t.left);</span><br><span class="line">            int rbalfactor=getBalancedFactor(t.right);</span><br><span class="line">            if(balfactor&gt;1 &amp;&amp; lbalfactor&gt;=0)</span><br><span class="line">                return  rroate(root); //LL情况 进行右旋</span><br><span class="line">            if(balfactor&gt;1 &amp;&amp; lbalfactor&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                t.left=lroate(t.left);</span><br><span class="line">                return  rroate(t); //先左旋变成lr 再右旋</span><br><span class="line">            &#125;</span><br><span class="line">            if(balfactor&lt;-1 &amp;&amp; rbalfactor&lt;0)</span><br><span class="line">                return  lroate(t); //rr</span><br><span class="line">            if(balfactor&lt;-1 &amp;&amp; rbalfactor&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                t.right=rroate(t.right);</span><br><span class="line">                return  lroate(t);</span><br><span class="line">            &#125;</span><br><span class="line">        return  t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public  static  void main(String[] args)&#123;</span><br><span class="line">        int[] a=&#123;16,3,7,11,9, 28,18,14,15&#125;;</span><br><span class="line">        avlTree tree=new avlTree();</span><br><span class="line">        for(int x:a)</span><br><span class="line">        &#123;</span><br><span class="line">            tree.insert(x);</span><br><span class="line">            tree.pr();</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二叉平衡搜索树（avl树）满足以下定义：&lt;/p&gt;
&lt;p&gt; 1：为二叉搜索树&lt;/p&gt;
&lt;p&gt; 2：左子树与右子树高度差不超过1&lt;/p&gt;
&lt;p&gt; 3: 左右子树均为avl树&lt;/p&gt;
&lt;p&gt;主要实现了插入和删除操作&lt;/p&gt;
&lt;p&gt;我们每个节点用一个int值记录当前节点的高度，叶子</summary>
      
    
    
    
    <category term="算法" scheme="https://yjpwzy1314.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="avltree" scheme="https://yjpwzy1314.com/tags/avltree/"/>
    
  </entry>
  
  <entry>
    <title>first</title>
    <link href="https://yjpwzy1314.com/2020/12/21/first/"/>
    <id>https://yjpwzy1314.com/2020/12/21/first/</id>
    <published>2020-12-21T03:53:21.000Z</published>
    <updated>2021-06-02T06:26:18.477Z</updated>
    
    <content type="html"><![CDATA[<p>菜鸡的自我介绍</p><hr><p>袁军平<br>南大软院大二本科生 目前菜鸡一枚<br>lol爱好者，锐雯 蛮王专精玩家<br>喜欢看一些国漫 天行九歌 斗破苍穹之类的<br>会一点乒乓球和羽毛球<br>目前想学一下web技术（自己做一个小的项目），想啃点算法，想搞好线代（x）<br>国家级退堂鼓表演大师<br>一年半在南大软院的时间好像没学什么。细细想来大一上学了些简单的py和c。大一下在家里实在学习效率很差，每天打打游戏上上网课就过去了。好像只学了一些简单的java语法？和jvm的一些知识。大二上目前还没过完。尚不置评。<br>经常吐槽软院的教学，希望自己能找机会多学一些东西（虽然自己的自制力实在是很拉闸）<br>而且自己的记忆力确实不太好（我也想有个好脑瓜），看到wgg的博客写了好多很有用的东西，觉得写博客或许是个好的记录方式？（在此特别感谢wgg）<br>以上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;菜鸡的自我介绍&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;袁军平&lt;br&gt;南大软院大二本科生 目前菜鸡一枚&lt;br&gt;lol爱好者，锐雯 蛮王专精玩家&lt;br&gt;喜欢看一些国漫 天行九歌 斗破苍穹之类的&lt;br&gt;会一点乒乓球和羽毛球&lt;br&gt;目前想学一下web技术（自己做一个小的项目），想啃点算法，想搞好</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>kmp</title>
    <link href="https://yjpwzy1314.com/2020/12/21/kmp/"/>
    <id>https://yjpwzy1314.com/2020/12/21/kmp/</id>
    <published>2020-12-21T03:53:10.000Z</published>
    <updated>2021-06-02T06:51:51.627Z</updated>
    
    <content type="html"><![CDATA[<p>字符串匹配-kmp算法</p><p>（第一次用md写东西，语法不太会，可能格式有点拉闸）</p><p>字符串匹配问题指的是给定两个字符串s1(母串)以及s2（模式串），判断母串是否包含模式串，如果包含，模式串首先出现在母串的哪个位置的一类问题。</p><p>对于这类问题，我们首先能想到的就是一种暴力解法，即从s1的每个字符开始，判断从这个字符开始有没有和s2相同的子串。</p><p>我们假定s1的长度为n，s2的长度为m</p><p>这种暴力解法的时间复杂度为O(mn)显然这不是我们能接受的。</p><p>考虑这种暴力解法存在的问题。</p><p>S1:abcdabced</p><p>S2:abce</p><p>假定我们使用的指针是i和j，使用这种朴素的解法时，从第一个字符遍历时，当i&#x3D;4，j&#x3D;4时我们退出循环，同时又从i&#x3D;2与j&#x3D;0开始遍历。</p><p>但其实我们这时已经知道的是s1的前三位与s2的前三位是相同的。我们忽略了这个信息。换句话说，我们之前计算的结果被我们抛弃掉了。第一个字符遍历在哪里停止对之后的算法都不会产生任何影响。</p><p>S1:abababcd</p><p>S2:ababcd</p><p>下面介绍一下kmp算法，这种算法复杂度可以达到线性时间。</p><p>我们注意到这样一个事实。</p><p>假设匹配失败时，s2中的指针位于s2的j位置。如果s2的[0:n-1]子串，存在一对前缀和后缀是相同的，假设长度为k，那么我们可以直接让j回退到位置k开始匹配。直观地讲就是利用了这部分前缀和后缀相同，s1中后缀和s2中的前缀对应来减少比较次数。</p><p>如s1和s2在位置4匹配失败。子串abab对应的k为2，我们这时已经比较的可以认为是s1[2:4]与s2的[0:2] 从i&#x3D;4,j&#x3D;2开始比较即可.</p><p>于是kmp算法的基本框架如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int kmp(string s1,string s2)&#123;</span><br><span class="line">    setnext(s2);</span><br><span class="line">    int p1=0;</span><br><span class="line">    int p2=0;</span><br><span class="line">    while(p2&lt;s2.length() &amp;&amp; p1&lt;s1.length())</span><br><span class="line">    &#123;</span><br><span class="line">        if(s1[p1]==s2[p2])</span><br><span class="line">        &#123;</span><br><span class="line">            p1++; p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p2==0) p1++;</span><br><span class="line">        else p2=nxt[p1];</span><br><span class="line">    &#125;</span><br><span class="line">    if(p2==s2.length())</span><br><span class="line">        return  p1-p2;  //匹配成功</span><br><span class="line">    return  -1;  //匹配失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面问题的关键则是获得next数组。</p><p>next数组的定义：next[i]代表子串[0:i]的前缀和后缀相等的最大前缀长度。</p><p>至于next数组的得出，我们考虑用一种递推的方式。</p><p>如果我们知道了next[0],next[1]……next[n-1]怎么得到next[n]呢。</p><p>记next[n-1]为now</p><p>很容易想到，如果S[n]是等于S[next[n-1]]的，那么next[n]&#x3D;next[n-1]+1;</p><p>如果不等，接下来我们让now缩小，直至符合要求。</p><p>now如何缩小并且满足s的now-前缀和s的now-后缀是相等呢？</p><p>我们注意到当前的前缀与后缀是相同的，故我们只需取next[now-1]即可（这样是四部分相同，仍然满足前缀等于后缀的条件）</p><p>如果now缩小到0说明当前i匹配失败，i直接+1即可。</p><p>kmp c++代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace  std;</span><br><span class="line">vector&lt;int &gt; nxt;</span><br><span class="line">void setnext(string s)&#123;</span><br><span class="line">   int p=1;</span><br><span class="line">   int now=0;</span><br><span class="line">   nxt.push_back(0);</span><br><span class="line">   while(p&lt;s.length())</span><br><span class="line">   &#123;</span><br><span class="line">       if(s[now]==s[p])&#123;</span><br><span class="line">           p++;now++;</span><br><span class="line">           nxt.push_back(now);</span><br><span class="line">       &#125;</span><br><span class="line">       else if(now!=0)</span><br><span class="line">           now=nxt[now-1];</span><br><span class="line">       else &#123;</span><br><span class="line">           nxt.push_back(now);</span><br><span class="line">           p++;</span><br><span class="line">       &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">int kmp(string s1,string s2)&#123;</span><br><span class="line">    setnext(s2);</span><br><span class="line">    int p1=0;</span><br><span class="line">    int p2=0;</span><br><span class="line">    while(p2&lt;s2.length() &amp;&amp; p1&lt;s1.length())</span><br><span class="line">    &#123;</span><br><span class="line">        if(s1[p1]==s2[p2])</span><br><span class="line">        &#123;</span><br><span class="line">            p1++; p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p2==0) p1++;</span><br><span class="line">        else p2=nxt[p1];</span><br><span class="line">    &#125;</span><br><span class="line">    if(p2==s2.length())</span><br><span class="line">        return  p1-p2;  //匹配成功</span><br><span class="line">    return  -1;  //匹配失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kmp java：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Kmp &#123;</span><br><span class="line">    public  static  void  main(String[] args)&#123;</span><br><span class="line">        System.out.println(new Kmp().kmp(&quot;1234234&quot;,&quot;234&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    int [] setnext(String s)&#123;</span><br><span class="line">        int[] next=new int[s.length()];</span><br><span class="line">        next[0]=0;</span><br><span class="line">        int now=0;</span><br><span class="line">        int cur=1;</span><br><span class="line">        while(cur&lt;s.length())&#123;</span><br><span class="line">            if(s.charAt(now)==s.charAt(cur))</span><br><span class="line">            &#123;</span><br><span class="line">               now++; next[cur]=now;cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(now!=0)</span><br><span class="line">                now=next[now-1];</span><br><span class="line">            else &#123;</span><br><span class="line">                next[cur]=0;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   return  next;</span><br><span class="line">    &#125;</span><br><span class="line">    int  kmp(String s1,String s2)&#123;</span><br><span class="line">        int[] next=setnext(s2);</span><br><span class="line">        int i=0;int j=0;</span><br><span class="line">        while(i&lt;s1.length() &amp;&amp; j&lt;s2.length())</span><br><span class="line">        &#123;</span><br><span class="line">            if(s1.charAt(i)==s2.charAt(j))&#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(j!=0)j=next[j];</span><br><span class="line">            else i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j==s2.length()) return i-j;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;字符串匹配-kmp算法&lt;/p&gt;
&lt;p&gt;（第一次用md写东西，语法不太会，可能格式有点拉闸）&lt;/p&gt;
&lt;p&gt;字符串匹配问题指的是给定两个字符串s1(母串)以及s2（模式串），判断母串是否包含模式串，如果包含，模式串首先出现在母串的哪个位置的一类问题。&lt;/p&gt;
&lt;p&gt;对于这类问</summary>
      
    
    
    
    <category term="算法" scheme="https://yjpwzy1314.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>曲面和曲线</title>
    <link href="/2022/03/05/%E6%9B%B2%E9%9D%A2%E5%92%8C%E6%9B%B2%E7%BA%BF/"/>
    <url>/2022/03/05/%E6%9B%B2%E9%9D%A2%E5%92%8C%E6%9B%B2%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="显式几何"><a href="#显式几何" class="headerlink" title="显式几何"></a>显式几何</h2><h3 id="点云"><a href="#点云" class="headerlink" title="点云"></a>点云</h3><p>考虑点的集合 list of points(x,y,z)</p><h3 id="曲线-Curves"><a href="#曲线-Curves" class="headerlink" title="曲线 Curves"></a>曲线 Curves</h3><p>Bezier Curves</p><p><img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220305163441719.png" alt="image-20220305163441719"></p><p>控制点定义贝塞尔曲线</p><p>对于位置t的点来说</p><p><img src="https://pic4.zhimg.com/80/v2-a458012ad265c748f528c2c8652184f7_1440w.jpg" alt="img"></p><p>即<img src="https://www.zhihu.com/equation?tex=b_0%5E1+=+b_0+t*(b_1-b_0)" alt="[公式]">，得到 <img src="https://www.zhihu.com/equation?tex=b_0%5E1" alt="[公式]"> 之后在<img src="https://www.zhihu.com/equation?tex=b_1b_2" alt="[公式]">线段上重复做相同的线性插值得到点<img src="https://www.zhihu.com/equation?tex=b_1%5E1" alt="[公式]">:</p><p><img src="https://pic3.zhimg.com/v2-77fddee24adf559aa0436b122fedfe22_r.jpg" alt="preview"></p><p>最终对于给定t 其坐标计算如上图所示</p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学笔记1-布林冯反射模型</title>
    <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B01-%E5%B1%80%E9%83%A8%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B01-%E5%B1%80%E9%83%A8%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="布林冯反射模型"><a href="#布林冯反射模型" class="headerlink" title="布林冯反射模型"></a>布林冯反射模型</h2><p>在光栅化后，需要给物体上色</p><p>这里记录一个上色模型 Blinn-Phong Reflectance Model</p><p>局部光照系统</p><p><img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220304003951316.png" alt="image-20220304003951316"></p><p>如上图所示。一个物体的光照是由三部分组成的。环境光照，漫反射，镜面反射。</p><p><strong>环境光照</strong></p><p>在布林冯反射模型中，环境光照认为是一个常数。</p><p><img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220304013527522.png" alt="image-20220304013527522"></p><p><strong>漫反射</strong></p><p><img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220304012835911.png" alt="image-20220304012835911"></p><p>如上图所示，对于一个平面，入射光线的方向与平面的法线的夹角显然影响这个点的漫反射强度。</p><p>具体的来说，如果入射光的强度为n 那么入射平面接收到的光照强度为 n*cos(l,n)</p><p>同时在光的传播过程中，接受点与光源的距离也会影响光的强度。</p><p>综合以上<img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220304013238528.png" alt="image-20220304013238528"></p><p>其中kd是该点的漫反射系数。max(0,n*l)是为了剔除与法线方向夹脚大于90度的入射光线（这种情况下没有物理意义）</p><p>这里要注意的漫反射的反射光强度和出射方向无关。</p><p><strong>镜面反射</strong></p><p>镜面反射的强度与人的观察角度有关系。即下图中R与V的夹角</p><p><img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220304013711536.png" alt="image-20220304013711536"></p><p>但是计算V是很麻烦的。布林冯模型中的替代是计算半程向量</p><p><img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220304013845231.png" alt="image-20220304013845231"></p><p>这种情况的近似也会有很好的结果。</p><p>最终的镜面反射光强计算公式为：<img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220304014117842.png" alt="image-20220304014117842"></p><p>这里引入了一个指数P 我的理解是它的作用是控制夹角对光强的影响程度 随着夹角增大需要使光强变小的速度更快。</p><p>直观的理解就是如果不引入指数P 在夹角为45度的时候还是有一定程度的高光。最终渲染出来的结果是高光部分很多。很影响观感。</p><p><img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/image-20220304014536645.png" alt="image-20220304014536645"></p><h3 id="Hw3中布林冯反射模型部分"><a href="#Hw3中布林冯反射模型部分" class="headerlink" title="Hw3中布林冯反射模型部分"></a>Hw3中布林冯反射模型部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Eigen::Vector3f <span class="title">phong_fragment_shader</span><span class="params">(<span class="type">const</span> fragment_shader_payload&amp; payload)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Eigen::Vector3f ka = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.005</span>, <span class="number">0.005</span>, <span class="number">0.005</span>);</span><br><span class="line">    Eigen::Vector3f kd = payload.color;</span><br><span class="line">    Eigen::Vector3f ks = Eigen::<span class="built_in">Vector3f</span>(<span class="number">0.7937</span>, <span class="number">0.7937</span>, <span class="number">0.7937</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> l1 = light&#123;&#123;<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> l2 = light&#123;&#123;<span class="number">-20</span>, <span class="number">20</span>, <span class="number">0</span>&#125;, &#123;<span class="number">500</span>, <span class="number">500</span>, <span class="number">500</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;light&gt; lights = &#123;l1, l2&#125;;</span><br><span class="line">    Eigen::Vector3f amb_light_intensity&#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Eigen::Vector3f eye_pos&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">150</span>;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f color = payload.color;</span><br><span class="line">    Eigen::Vector3f point = payload.view_pos;</span><br><span class="line">    Eigen::Vector3f normal = payload.normal;</span><br><span class="line"></span><br><span class="line">    Eigen::Vector3f result_color = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; light : lights)</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::Vector3f ambient=ka.<span class="built_in">cwiseProduct</span>(amb_light_intensity);</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3f light_view=light.position-point;</span><br><span class="line">        Eigen::Vector3f eye_view=eye_pos-point;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span>  r=light_view.<span class="built_in">dot</span>(light_view); <span class="comment">//距离平方</span></span><br><span class="line">        <span class="comment">//漫反射</span></span><br><span class="line">        Eigen::Vector3f t= (light.intensity/r)*std::<span class="built_in">max</span>(<span class="number">0.f</span>,normal.<span class="built_in">dot</span>(light_view.<span class="built_in">normalized</span>()));</span><br><span class="line">        Eigen::Vector3f diffuse=kd.<span class="built_in">cwiseProduct</span>(t);</span><br><span class="line">        <span class="comment">//镜面反射</span></span><br><span class="line">        Eigen::Vector3f half=(eye_view+light_view).<span class="built_in">normalized</span>();</span><br><span class="line">        t=(light.intensity/r)*<span class="built_in">pow</span>(std::<span class="built_in">max</span>(<span class="number">0.f</span>,normal.<span class="built_in">dot</span>(half)),p);</span><br><span class="line">        Eigen::Vector3f specular=ks.<span class="built_in">cwiseProduct</span>(t);</span><br><span class="line">        result_color+=ambient;</span><br><span class="line">        result_color+=diffuse;</span><br><span class="line">        result_color+=specular;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular*</span></span><br><span class="line">        <span class="comment">// components are. Then, accumulate that result on the *result_color* object.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result_color * <span class="number">255.f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染出来的结果：</p><p><img src="https://yjpp.oss-cn-hangzhou.aliyuncs.com/uPic/phong.png" alt="phong"></p>]]></content>
    
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DHCP,Routing</title>
    <link href="/2021/06/08/DHCP/"/>
    <url>/2021/06/08/DHCP/</url>
    
    <content type="html"><![CDATA[<h3 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP 动态主机配置协议"></a>DHCP 动态主机配置协议</h3><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>发现：client广播发出dhcp报文</p><p>响应：server在ip地址池中查找合法的ip地址，发出dhcpoffer报文给client，</p><p>选择：client选择一个offer报文，发送一个dhcp request广播数据包</p><p>租约确定：server接到request后 如果广播成功，以ack确认，反之以nak确认</p><p>租期续约：DHCP Client直接向为其提供IP地址的DHCP Server发送DHCP Request消息，收到回应的DHCP ACK消息 后， DHCP Client根据所提供的新的租期以及其它更新的 TCP&#x2F;IP参数更新自己的配置，IP租用更新完成</p><p>租期释放：client不需要分配ip地址时 发送release报文 释放租约</p><h4 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h4><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608195554228.png" alt="image-20210608195554228"></p><p>op：报文类型1表示请求 0代表应答</p><p>htype：硬件类型</p><p>hlen：长度</p><h4 id="DHCP欺骗以及防范"><a href="#DHCP欺骗以及防范" class="headerlink" title="DHCP欺骗以及防范"></a>DHCP欺骗以及防范</h4><p> client 通过广播寻找服务器，只接受第一个到达的</p><p>非授权的dhcp先应答，就被欺骗</p><h5 id="防范："><a href="#防范：" class="headerlink" title="防范："></a>防范：</h5><p>​指定主机可以配置dhcp server（很难防范）</p><p>​ciso：交换机使用dhcp snoping 只有认证过的dhcp server才可以通过交换机</p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608200651144.png" alt="image-20210608200651144"></p><p>RAM 访问比较快 不用顺序 </p><p>存储 路由表 ARP 快速交换的缓存</p><p> nvram （既希望访问快，又希望没电时也可以，用特定电池） 用来保存一些配置信息 </p><p>flash 相当于磁盘 可以更改 读写一般来说比磁盘快 放网络操作系统等待</p><p>rom（readonlymemory） 放post</p><p>路由器启动过程：</p><p>1.post 检查硬件信息等是否正确（与rom对比）</p><p>2.定位ios 载入ios</p><p>3.引入nvram配置信息（如果没有，引入手工配置）</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608202329551.png" alt="image-20210608202329551"></p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>静态路由：手动配置 </p><p> 动态路由：动态选择</p><p>A-》C 如果使用静态路由 配置A到D 如果A到D出问题就无法传输  </p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210609002933782.png" alt="image-20210609002933782"></p><p>动态路由协议 主要介绍RGP 内部网关协议</p><p>三类 <img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210609003921148.png" alt="image-20210609003921148"></p><p>distance vector：路由器之间交换信息，一段时间后形成一个稳定的状态</p><p>可能生成回路（我知道可达，但可能是通过我达到的，形成冗余回路）</p><p>回路处理机制：</p><p>1.定义一个最大值，例如最大值是15跳，否则认为不可达</p><p>2.route poison  传播不可达的信息</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210609005344833.png" alt="image-20210609005344833"></p><p>3.水平分割</p><p>路由器从某个端口接受的信息不能再从这个端口发送回去</p><ol start="4"><li><p>hold-down timers 收到网络信息不可达后，起个计时器，计时期间如果有更好的到达方式就接收</p><h3 id="LS-链路状态"><a href="#LS-链路状态" class="headerlink" title="LS 链路状态"></a>LS 链路状态</h3><p>LINK-STATE Protocol</p><p>基于全局生成树，做路由表 不会有回路</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OSI模型</title>
    <link href="/2021/06/08/OSI%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/06/08/OSI%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h3><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608115801644.png" alt="image-20210608115801644"></p><h4 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a>1.物理层</h4><h4 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h4><h4 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h4><h4 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h4><h4 id="5-Layer-5-7-会话层-表示层-应用层"><a href="#5-Layer-5-7-会话层-表示层-应用层" class="headerlink" title="5.Layer 5-7 会话层 表示层 应用层"></a>5.Layer 5-7 会话层 表示层 应用层</h4><h5 id="会话层："><a href="#会话层：" class="headerlink" title="会话层："></a>会话层：</h5><p>开始会话前包括同步管理，双工或是半双工等。</p><p>建立连接 传输数据 每次传完数据同步一次（次同步点） 每传输几次建立一个主同步点，如果出现故障就会返回主同步点（恢复点）。</p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608114718638.png" alt="image-20210608114718638"></h4><h5 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h5><p>​解决不同系统的编码等问题（展示成接收方可以理解）</p><p>​主要功能：数据格式，数据压缩标准，数据加密</p><p>​先协商编码标准等</p><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>​为用户提供服务 不同协议有不同应用情况</p><p>http：超文本传输协议</p><p>html: 超文本标记语言</p><p>统一资源定位符 URL 对因特网上得到的资源位置和访问方法的一种简洁表示</p><p>&lt;url访问方式&gt;&lt;主机(ip)&gt;&lt;端口&gt;&lt;路径&gt;</p><p>面向事务，无状态，无连接，http daemon ：万维网服务器等待http请求的进程</p><p>http报文结构：</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608123208218.png" alt="image-20210608123208218"></p><p>ftp与tftp</p><p>ftp：可靠的面向连接的文件传输服务 基于tcp</p><p>端口21 控制连接</p><p>端口20 数据传输（连接成功）</p><p>tftp 不面向连接 基于udp 容易去部署 不支持交互</p><p>ftp主进程工作</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608132245390.png" alt="image-20210608132245390"></p><p>本地命令 翻译到标准格式 传送到服务器 ftp服务器翻译成服务器的格式</p><p>email 使用smtp与pop3</p><p>smtp 规定两个相互通信的进程的信息传送 c</p><p>Pop3 接受邮件</p><p>MIME标准 将用户的一些非ascii数据转换成ascii数据</p><h4 id="SNMP-简单网络管理协议"><a href="#SNMP-简单网络管理协议" class="headerlink" title="SNMP 简单网络管理协议"></a>SNMP 简单网络管理协议</h4><h4 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS 域名系统"></a>DNS 域名系统</h4><p>ip映射到域名，使用者通过域名访问</p><p>越后面的level 域名等级越高</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608165020286.png" alt="image-20210608165020286"></p><p>全球有多个根域名服务器供dns解析 </p><p>配置一个主机 ip 子网掩码 网关 dnsserver </p><p> 本地域名器内解析逐层递归请求 请求到后逐层返还 </p><p> 本地服务器之上就是直接访问根域名服务器</p><p>本地域名服务器在拿到结果后会存到本地数据库</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608191431197.png" alt="image-20210608191431197"></p><p>应用层通信两种分类：</p><p>www.,http通信 无上下文连接</p><p>talent，ftp，维持上下文</p>]]></content>
    
    
    
    <tags>
      
      <tag>互联网计算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACL</title>
    <link href="/2021/06/02/ACL/"/>
    <url>/2021/06/02/ACL/</url>
    
    <content type="html"><![CDATA[<p>防火墙：软件硬件构成的系统，特殊编程的路由器，两个网络之间实施介入控制策略。</p><p>防火墙内部是可以信赖的。外部是不可信赖的互联网。</p><p>![image-20210606154155012](&#x2F;Users&#x2F;yjp&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20210606154155012.png)</p><p>防火墙功能：阻止与允许</p><p>阻止：阻止 某种通信量通过防火墙，可以是内部到外部也可以是外部到内部。</p><h4 id="防火墙技术"><a href="#防火墙技术" class="headerlink" title="防火墙技术"></a>防火墙技术</h4><h5 id="网络级防火墙"><a href="#网络级防火墙" class="headerlink" title="网络级防火墙"></a>网络级防火墙</h5><p>​分组过滤：检查所有流入本网络的信息</p><p>​授权服务器：检查用户登陆是否合法。</p><h5 id="应用级防火墙"><a href="#应用级防火墙" class="headerlink" title="应用级防火墙"></a>应用级防火墙</h5><p>应用程序进行接入控制</p><h3 id="ACL-访问控制列表"><a href="#ACL-访问控制列表" class="headerlink" title="ACL  访问控制列表"></a>ACL  访问控制列表</h3><p>默认情况下路由器是让所有报文通过的。如果想让一些报文无法通过就需要配置acl。</p><h4 id="标准ACL（基于原地址）"><a href="#标准ACL（基于原地址）" class="headerlink" title="标准ACL（基于原地址）"></a>标准ACL（基于原地址）</h4><p>阻止报文需要：</p><p>源地址，目的地址，上层协议的内容(如端口)。</p><p>报文处理：</p><p>报文和所有语句按顺序进行匹配。有匹配的话后面的语句就不进行计算。</p><p>一个报文要么通过要么匹配</p><p>如果所有语句都不匹配就默认deny</p><h5 id="路由器使用acl"><a href="#路由器使用acl" class="headerlink" title="路由器使用acl"></a>路由器使用acl</h5><p>1.先检查packet是否可以路由。如果可以，进行2</p><p>2.检查是否有acl配置 有acl配置就进行acl校验 选择拒绝转发或者允许转发 如果没acl配置就直接转发。</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210606165321437.png" alt="image-20210606165321437"></p><p>标准acl配置：</p><p>全局配置情况下：access-list number permint&#x2F;deny ip</p><p>interface : ip access-group number  out&#x2F;in</p><p>标准acl要放在里要控制的目标主机越近越好，避免对源地址影响大</p><p>标准acl在有些情况下对带宽消耗大</p><h3 id="扩展ACL"><a href="#扩展ACL" class="headerlink" title="扩展ACL"></a>扩展ACL</h3><p>扩展acl （100-199）</p><p>可以基于目标地址进行操作，ip协议的位置，上层的tcp&#x2F;ip协议</p><p>扩展acl格式</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/image-20210608001902287.png" alt="image-20210608001902287"></p><p>扩展acl在配置时尽量选择距离源地址近的地方配置 可以避免传输过程中带宽的浪费。</p>]]></content>
    
    
    <categories>
      
      <category>互联网计算</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>printCycles</title>
    <link href="/2020/12/28/printCycles/"/>
    <url>/2020/12/28/printCycles/</url>
    
    <content type="html"><![CDATA[<p>问题描述很简单：判断图中是否有环路，如果有环路，打印出来。</p><p>我采用深度优先搜索的方式来解决这个问题。</p><p><strong>解题思路</strong></p><p>从图的第一个顶点开始搜索，用一个数组path记录已经搜索过的节点。同时用一个数组vis记录节点是否已经访问过。 当我们搜索时，我们用vis来判断当前节点是否访问过，如果访问过，我们就发现了一个环路（因为之前我们已经到过这个节点，现在又到这个节点了，说明就这个路就是一个环） 这个时候我们退出循环，把之前访问到的这个节点到第二次访问到这个节点的中所有的节点都打印出来。就是一个环。同时我们要用一个int值n来记录当前是搜索路径上的第几个节点</p><p>我们来简单地看个例子。</p><p><img src="https://se2.oss-cn-beijing.aliyuncs.com/uPic/graph.jpg" alt="graph"></p><p>下一个搜索的节点为节点1，path为{0,1}</p><p>节点1搜索的第一个节点为2，节点2搜索的第一个节点为3，节点3搜索的第一个节点为0，搜索到0的时候我们发现0我们好像已经访问过了，于是乎就找到了一个环，此时path为{0，1，2，3，0}，然后返回。这个时候深搜返回到节点3（因为节点3要搜节点0和节点4，节点1），节点3依次搜索节点4，0，搜索到0的时候我们发现这又是一个环路。path为{0,1,2,3,4,0},打印，</p><p>从节点3返回至节点2，节点2只有节点3要搜，所以返回到节点1.节点1继续搜至节点3，此时path为{0,1,3}节点3先搜索至节点0,path为{0,1,3,0};打印后返回</p><p>搜索节点4至节点0 path为{0,1,3,4,0};</p><p>最终所有环路为</p><p>0 1 2 3 0；0 1 2 3 4 0； 0 1 3 0；0 1 3 4 0；</p><p>贴个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class Graph &#123;</span><br><span class="line">    class vetrx&#123;</span><br><span class="line">        int id;</span><br><span class="line">        int val;</span><br><span class="line">        public  vetrx()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        public vetrx(int i, int i1) &#123;</span><br><span class="line">            this.id=i;</span><br><span class="line">            this.val=i1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vetrx[] vetrxs;</span><br><span class="line">    int vnum;</span><br><span class="line">    HashMap&lt;vetrx ,LinkedList&lt;vetrx&gt;&gt; graph=new HashMap&lt;&gt;();</span><br><span class="line">    int[][] w;</span><br><span class="line">    HashMap&lt;vetrx,Integer&gt; Dijkstra(vetrx v)&#123;</span><br><span class="line">        HashMap&lt;vetrx,Integer&gt; ans=new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        return  null;</span><br><span class="line">    &#125;</span><br><span class="line">    public  Graph(int[] vet,int[][] gra)&#123;</span><br><span class="line">        this.vnum=vet.length;</span><br><span class="line">        this.vetrxs=new vetrx[vnum];</span><br><span class="line">        for(int i=0;i&lt;vnum;i++)</span><br><span class="line">        &#123;   vetrxs[i]=new vetrx(i,vet[i]); &#125;</span><br><span class="line">        for(int i=0;i&lt;vnum;i++)&#123;</span><br><span class="line">            LinkedList&lt;vetrx&gt; vs=new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            for(int j=0;j&lt;vnum;j++)&#123;</span><br><span class="line">               if(gra[i][j]!=0)</span><br><span class="line">                   vs.add(vetrxs[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            graph.put(vetrxs[i],vs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;vetrx&gt; path=new LinkedList();</span><br><span class="line">    void dfs(vetrx v,int n , boolean[] vis)&#123;</span><br><span class="line">        if(n==vnum+2)</span><br><span class="line">            return;</span><br><span class="line">        path.set(n,v);</span><br><span class="line">        if(vis[v.id])&#123;</span><br><span class="line">            int first=path.indexOf(v);</span><br><span class="line">            for(int i=first;i&lt;=n;i++)</span><br><span class="line">                System.out.print(path.get(i).id);</span><br><span class="line">            System.out.println();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[v.id]=true;</span><br><span class="line">        for(vetrx nxt:graph.get(v))</span><br><span class="line">            dfs(nxt,n+1,vis);</span><br><span class="line">        vis[v.id]=false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  void printallthecycle()&#123;</span><br><span class="line">        for(int i=0;i&lt;vnum+2;i++)</span><br><span class="line">           path.add(new vetrx());</span><br><span class="line">        LinkedList&lt;vetrx&gt; p=new LinkedList&lt;&gt;();</span><br><span class="line">        boolean vis[] =new boolean[vnum];</span><br><span class="line">        p.add(vetrxs[0]);</span><br><span class="line">        dfs(vetrxs[0],1,vis);</span><br><span class="line"></span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>graph类有个构造函数 第一个数组用来说明图节点的val，第二个数组用来说明节点之间边的关系。这个类的边关系用hashmap存储。</p><p>这边有一个函数用来测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package test;</span><br><span class="line"></span><br><span class="line">import ADT.Graph;</span><br><span class="line">import ADT.Tree;</span><br><span class="line">import ADT.node;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.PrintStream;</span><br><span class="line"></span><br><span class="line">import static org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line">public class Graphtest &#123;</span><br><span class="line">    PrintStream oldPrintStream = System.out; //将原来的System.out交给printStream 对象保存</span><br><span class="line">    ByteArrayOutputStream bos = new ByteArrayOutputStream();</span><br><span class="line">    @Before</span><br><span class="line">   public void init()&#123;</span><br><span class="line"></span><br><span class="line">       System.setOut(new PrintStream(bos));</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public  void printcycletest1()</span><br><span class="line">    &#123; int[] vrtexs=&#123;1,2,3,4,5,6,7,8&#125;;</span><br><span class="line">        int[][] gra=new int[8][8];</span><br><span class="line">        for(int i=0;i&lt;4;i++)</span><br><span class="line">            gra[i][i+1]=1;</span><br><span class="line">        gra[4][1]=1;</span><br><span class="line">        gra[1][1]=1;</span><br><span class="line">        gra[3][5]=1;</span><br><span class="line">        gra[5][6]=1;</span><br><span class="line">        gra[6][7]=1;</span><br><span class="line">        gra[7][5]=1;</span><br><span class="line">        Graph graph=new Graph(vrtexs,gra);</span><br><span class="line">        graph.printallthecycle();</span><br><span class="line">        assertEquals(bos.toString(),&quot;11\n&quot; +</span><br><span class="line">                &quot;12341\n&quot; +</span><br><span class="line">                &quot;5675\n&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public  void printcycletest2()&#123;</span><br><span class="line">        int[] vrtexs=&#123;0,1,2,3,4&#125;;</span><br><span class="line">        int [][] gra=new int[5][5];</span><br><span class="line">        gra[0][1]=1;</span><br><span class="line">        gra[1][2]=1; gra[1][3]=1;gra[2][3]=1;gra[3][0]=1;</span><br><span class="line">        gra[3][4]=1;gra[4][0]=1;</span><br><span class="line">        Graph graph=new Graph(vrtexs,gra);</span><br><span class="line">        graph.printallthecycle();</span><br><span class="line">        assertEquals(bos.toString(),&quot;01230\n&quot; +</span><br><span class="line">                &quot;012340\n&quot; +</span><br><span class="line">                &quot;0130\n&quot; +</span><br><span class="line">                &quot;01340\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么多，希望老婆大大看完如果有不懂的可以马上来问我（这篇博客是因为老婆因为这个算法心情不好所以写的555）老婆心情不好俺自己心情也不好了</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>avltree</title>
    <link href="/2020/12/21/avltree/"/>
    <url>/2020/12/21/avltree/</url>
    
    <content type="html"><![CDATA[<p>二叉平衡搜索树（avl树）满足以下定义：</p><p> 1：为二叉搜索树</p><p> 2：左子树与右子树高度差不超过1</p><p> 3: 左右子树均为avl树</p><p>主要实现了插入和删除操作</p><p>我们每个节点用一个int值记录当前节点的高度，叶子结点高度为1。</p><p>我们引入平衡因子的概念（BalancedFactor）来帮助恢复平衡。</p><p>插入操作：利用二叉搜索树的性质找到待插入的位置</p><p>插入后需要检查树是否平衡。</p><p>不平衡的可能情况有四种</p><p>LL，LR，RL，RR（其实这里应该有图然后来分析的，但是我目前没找到什么好用的工具x，以后再补上吧）</p><p>LL：右旋即可</p><p>LR：对当前节点的左子节点左旋变为LL情况，然后右旋即可</p><p>RR：左旋</p><p>RL：当前节点的右子节点右旋变为RR情况，然后左旋即可</p><p>左旋和右旋的操作。俺就不多赘述了 ，网上比较多。</p><p>删除操作：</p><p> 如果要删除的节点不存在直接返回即可。</p><p> 如果要删除的节点是叶子结点。直接删除。</p><p> 如果要删除的节点只有一个子节点。用该子节点替换要删除的节点即可。</p><p> 如果要删除的节点有两个子节点。找到该节点的右子树的最小节点。用该节点的值替换待删除节点的值。递归地在右子树删除最小节点（递归到删除叶子结点的情况）</p><p>在每次删除操作完成后，更新节点高度，并检查avl树是否需要调整。</p><p>avl树 java实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">import  java.util.Queue;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class avlTree &#123;</span><br><span class="line">    private  class Node&#123;</span><br><span class="line">        Node(int val)&#123;</span><br><span class="line">            this.val=val;</span><br><span class="line">            this.height=1;</span><br><span class="line">        &#125;</span><br><span class="line">        int val;</span><br><span class="line">        Node left;</span><br><span class="line">        Node  right;</span><br><span class="line">        int height;</span><br><span class="line">    &#125;</span><br><span class="line">    Node root;</span><br><span class="line">    void del(int val)&#123;</span><br><span class="line">        this.root=del(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    void  insert(int val)&#123;</span><br><span class="line">        this.root=insert(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">    void updateheight(Node t)&#123;</span><br><span class="line">        t.height=Math.max(getheight(t.left),getheight(t.right))+1;</span><br><span class="line">    &#125;</span><br><span class="line">    Node insert(Node root,int val)&#123;</span><br><span class="line">        Node newnode=new Node(val);</span><br><span class="line">        if(root==null)</span><br><span class="line">            return newnode;</span><br><span class="line">        if(val&gt;root.val)</span><br><span class="line">            root.right=insert(root.right,val);</span><br><span class="line">        else</span><br><span class="line">            root.left=insert(root.left,val);</span><br><span class="line">        updateheight(root);</span><br><span class="line">        int balfactor=getBalancedFactor(root);</span><br><span class="line">        int lbalfactor=getBalancedFactor(root.left);</span><br><span class="line">        int rbalfactor=getBalancedFactor(root.right);</span><br><span class="line">        if(balfactor&gt;1 &amp;&amp; lbalfactor&gt;=0)</span><br><span class="line">            return  rroate(root); //LL情况 进行右旋</span><br><span class="line">        if(balfactor&gt;1 &amp;&amp; lbalfactor&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            root.left=lroate(root.left);</span><br><span class="line">            return  rroate(root); //先左旋变成lr 再右旋</span><br><span class="line">        &#125;</span><br><span class="line">        if(balfactor&lt;-1 &amp;&amp; rbalfactor&lt;0)</span><br><span class="line">            return  lroate(root); //rr</span><br><span class="line">       if(balfactor&lt;-1 &amp;&amp; rbalfactor&gt;=0)</span><br><span class="line">       &#123;</span><br><span class="line">           root.right=rroate(root.right);</span><br><span class="line">           return  lroate(root);</span><br><span class="line">       &#125;</span><br><span class="line">       return  root;</span><br><span class="line">    &#125;</span><br><span class="line">    Node lroate(Node  y)&#123;  // 左旋</span><br><span class="line">        Node  x=y.right;</span><br><span class="line">        Node  temp=x.left;</span><br><span class="line">        x.left=y;</span><br><span class="line">        y.right=temp;</span><br><span class="line">        updateheight(y);</span><br><span class="line">        updateheight(x);</span><br><span class="line">        return  x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node rroate(Node y)&#123;</span><br><span class="line">        Node x=y.left;</span><br><span class="line">        Node temp=x.right;</span><br><span class="line">        x.right=y;</span><br><span class="line">        y.left=temp;</span><br><span class="line">        updateheight(y);</span><br><span class="line">        updateheight(x);</span><br><span class="line">        return  x;</span><br><span class="line">    &#125;</span><br><span class="line">    void pr()&#123;</span><br><span class="line">        Queue&lt;Node&gt; q=new LinkedList&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        int curheight=getheight(root);</span><br><span class="line">        while(q.size()&gt;0)&#123;</span><br><span class="line">            Node t=q.poll();</span><br><span class="line">            if(t.height!=curheight)&#123;</span><br><span class="line">                curheight--;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(t.val+&quot;  &quot;);</span><br><span class="line">            if(t.left!=null) q.add(t.left);</span><br><span class="line">            if(t.right!=null) q.add(t.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public      int getheight(Node node)&#123;</span><br><span class="line">        if(node==null) return  0; return  node.height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  int getBalancedFactor(Node node)&#123;</span><br><span class="line"></span><br><span class="line">        return  node==null?0:getheight(node.left)-getheight(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  boolean isBST(Node rt)&#123;</span><br><span class="line">        if(rt==null) return  true;</span><br><span class="line">        if(rt.left==null &amp;&amp; rt.right==null) return  true;</span><br><span class="line">        if(rt.left==null)</span><br><span class="line">            return  rt.right.val&gt;rt.val &amp;&amp; isBST(rt.right);</span><br><span class="line">        if(rt.right==null)</span><br><span class="line">            return  rt.left.val&lt;rt.val &amp;&amp; isBST(rt.left);</span><br><span class="line">        return  rt.left.val&lt;rt.val &amp;&amp; rt.right.val&gt;rt.val &amp;&amp; isBST(rt.left) &amp;&amp; isBST(rt.right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    Node  del(Node t,int val)&#123;</span><br><span class="line">            if(t==null) return null;  //val 不存在</span><br><span class="line">            if(t.val==val)</span><br><span class="line">            &#123;</span><br><span class="line">                if(t.left==null &amp;&amp; t.right==null) return  null;</span><br><span class="line">                else if(t.left==null)  t=t.right;</span><br><span class="line">                else if(t.right==null) t=t.left;</span><br><span class="line">                else &#123;    //左右子树均不为空</span><br><span class="line">                    Node tar=t.right;</span><br><span class="line">                    while(tar.left!=null)</span><br><span class="line">                        tar=tar.left;</span><br><span class="line">                    t.val=tar.val;</span><br><span class="line">                    t.right=del(t.right,t.val); //</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(val&gt;t.val)</span><br><span class="line">                t.right=del(t.right,t.val);</span><br><span class="line">            if(val&lt;t.val)</span><br><span class="line">                t.left=del(t.left,t.val);</span><br><span class="line">            updateheight(t);</span><br><span class="line">            int balfactor=getBalancedFactor(t);</span><br><span class="line">            int lbalfactor=getBalancedFactor(t.left);</span><br><span class="line">            int rbalfactor=getBalancedFactor(t.right);</span><br><span class="line">            if(balfactor&gt;1 &amp;&amp; lbalfactor&gt;=0)</span><br><span class="line">                return  rroate(root); //LL情况 进行右旋</span><br><span class="line">            if(balfactor&gt;1 &amp;&amp; lbalfactor&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                t.left=lroate(t.left);</span><br><span class="line">                return  rroate(t); //先左旋变成lr 再右旋</span><br><span class="line">            &#125;</span><br><span class="line">            if(balfactor&lt;-1 &amp;&amp; rbalfactor&lt;0)</span><br><span class="line">                return  lroate(t); //rr</span><br><span class="line">            if(balfactor&lt;-1 &amp;&amp; rbalfactor&gt;=0)</span><br><span class="line">            &#123;</span><br><span class="line">                t.right=rroate(t.right);</span><br><span class="line">                return  lroate(t);</span><br><span class="line">            &#125;</span><br><span class="line">        return  t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public  static  void main(String[] args)&#123;</span><br><span class="line">        int[] a=&#123;16,3,7,11,9, 28,18,14,15&#125;;</span><br><span class="line">        avlTree tree=new avlTree();</span><br><span class="line">        for(int x:a)</span><br><span class="line">        &#123;</span><br><span class="line">            tree.insert(x);</span><br><span class="line">            tree.pr();</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>avltree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first</title>
    <link href="/2020/12/21/first/"/>
    <url>/2020/12/21/first/</url>
    
    <content type="html"><![CDATA[<p>菜鸡的自我介绍</p><hr><p>袁军平<br>南大软院大二本科生 目前菜鸡一枚<br>lol爱好者，锐雯 蛮王专精玩家<br>喜欢看一些国漫 天行九歌 斗破苍穹之类的<br>会一点乒乓球和羽毛球<br>目前想学一下web技术（自己做一个小的项目），想啃点算法，想搞好线代（x）<br>国家级退堂鼓表演大师<br>一年半在南大软院的时间好像没学什么。细细想来大一上学了些简单的py和c。大一下在家里实在学习效率很差，每天打打游戏上上网课就过去了。好像只学了一些简单的java语法？和jvm的一些知识。大二上目前还没过完。尚不置评。<br>经常吐槽软院的教学，希望自己能找机会多学一些东西（虽然自己的自制力实在是很拉闸）<br>而且自己的记忆力确实不太好（我也想有个好脑瓜），看到wgg的博客写了好多很有用的东西，觉得写博客或许是个好的记录方式？（在此特别感谢wgg）<br>以上</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>kmp</title>
    <link href="/2020/12/21/kmp/"/>
    <url>/2020/12/21/kmp/</url>
    
    <content type="html"><![CDATA[<p>字符串匹配-kmp算法</p><p>（第一次用md写东西，语法不太会，可能格式有点拉闸）</p><p>字符串匹配问题指的是给定两个字符串s1(母串)以及s2（模式串），判断母串是否包含模式串，如果包含，模式串首先出现在母串的哪个位置的一类问题。</p><p>对于这类问题，我们首先能想到的就是一种暴力解法，即从s1的每个字符开始，判断从这个字符开始有没有和s2相同的子串。</p><p>我们假定s1的长度为n，s2的长度为m</p><p>这种暴力解法的时间复杂度为O(mn)显然这不是我们能接受的。</p><p>考虑这种暴力解法存在的问题。</p><p>S1:abcdabced</p><p>S2:abce</p><p>假定我们使用的指针是i和j，使用这种朴素的解法时，从第一个字符遍历时，当i&#x3D;4，j&#x3D;4时我们退出循环，同时又从i&#x3D;2与j&#x3D;0开始遍历。</p><p>但其实我们这时已经知道的是s1的前三位与s2的前三位是相同的。我们忽略了这个信息。换句话说，我们之前计算的结果被我们抛弃掉了。第一个字符遍历在哪里停止对之后的算法都不会产生任何影响。</p><p>S1:abababcd</p><p>S2:ababcd</p><p>下面介绍一下kmp算法，这种算法复杂度可以达到线性时间。</p><p>我们注意到这样一个事实。</p><p>假设匹配失败时，s2中的指针位于s2的j位置。如果s2的[0:n-1]子串，存在一对前缀和后缀是相同的，假设长度为k，那么我们可以直接让j回退到位置k开始匹配。直观地讲就是利用了这部分前缀和后缀相同，s1中后缀和s2中的前缀对应来减少比较次数。</p><p>如s1和s2在位置4匹配失败。子串abab对应的k为2，我们这时已经比较的可以认为是s1[2:4]与s2的[0:2] 从i&#x3D;4,j&#x3D;2开始比较即可.</p><p>于是kmp算法的基本框架如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int kmp(string s1,string s2)&#123;</span><br><span class="line">    setnext(s2);</span><br><span class="line">    int p1=0;</span><br><span class="line">    int p2=0;</span><br><span class="line">    while(p2&lt;s2.length() &amp;&amp; p1&lt;s1.length())</span><br><span class="line">    &#123;</span><br><span class="line">        if(s1[p1]==s2[p2])</span><br><span class="line">        &#123;</span><br><span class="line">            p1++; p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p2==0) p1++;</span><br><span class="line">        else p2=nxt[p1];</span><br><span class="line">    &#125;</span><br><span class="line">    if(p2==s2.length())</span><br><span class="line">        return  p1-p2;  //匹配成功</span><br><span class="line">    return  -1;  //匹配失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面问题的关键则是获得next数组。</p><p>next数组的定义：next[i]代表子串[0:i]的前缀和后缀相等的最大前缀长度。</p><p>至于next数组的得出，我们考虑用一种递推的方式。</p><p>如果我们知道了next[0],next[1]……next[n-1]怎么得到next[n]呢。</p><p>记next[n-1]为now</p><p>很容易想到，如果S[n]是等于S[next[n-1]]的，那么next[n]&#x3D;next[n-1]+1;</p><p>如果不等，接下来我们让now缩小，直至符合要求。</p><p>now如何缩小并且满足s的now-前缀和s的now-后缀是相等呢？</p><p>我们注意到当前的前缀与后缀是相同的，故我们只需取next[now-1]即可（这样是四部分相同，仍然满足前缀等于后缀的条件）</p><p>如果now缩小到0说明当前i匹配失败，i直接+1即可。</p><p>kmp c++代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace  std;</span><br><span class="line">vector&lt;int &gt; nxt;</span><br><span class="line">void setnext(string s)&#123;</span><br><span class="line">   int p=1;</span><br><span class="line">   int now=0;</span><br><span class="line">   nxt.push_back(0);</span><br><span class="line">   while(p&lt;s.length())</span><br><span class="line">   &#123;</span><br><span class="line">       if(s[now]==s[p])&#123;</span><br><span class="line">           p++;now++;</span><br><span class="line">           nxt.push_back(now);</span><br><span class="line">       &#125;</span><br><span class="line">       else if(now!=0)</span><br><span class="line">           now=nxt[now-1];</span><br><span class="line">       else &#123;</span><br><span class="line">           nxt.push_back(now);</span><br><span class="line">           p++;</span><br><span class="line">       &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">int kmp(string s1,string s2)&#123;</span><br><span class="line">    setnext(s2);</span><br><span class="line">    int p1=0;</span><br><span class="line">    int p2=0;</span><br><span class="line">    while(p2&lt;s2.length() &amp;&amp; p1&lt;s1.length())</span><br><span class="line">    &#123;</span><br><span class="line">        if(s1[p1]==s2[p2])</span><br><span class="line">        &#123;</span><br><span class="line">            p1++; p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(p2==0) p1++;</span><br><span class="line">        else p2=nxt[p1];</span><br><span class="line">    &#125;</span><br><span class="line">    if(p2==s2.length())</span><br><span class="line">        return  p1-p2;  //匹配成功</span><br><span class="line">    return  -1;  //匹配失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kmp java：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Kmp &#123;</span><br><span class="line">    public  static  void  main(String[] args)&#123;</span><br><span class="line">        System.out.println(new Kmp().kmp(&quot;1234234&quot;,&quot;234&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    int [] setnext(String s)&#123;</span><br><span class="line">        int[] next=new int[s.length()];</span><br><span class="line">        next[0]=0;</span><br><span class="line">        int now=0;</span><br><span class="line">        int cur=1;</span><br><span class="line">        while(cur&lt;s.length())&#123;</span><br><span class="line">            if(s.charAt(now)==s.charAt(cur))</span><br><span class="line">            &#123;</span><br><span class="line">               now++; next[cur]=now;cur++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(now!=0)</span><br><span class="line">                now=next[now-1];</span><br><span class="line">            else &#123;</span><br><span class="line">                next[cur]=0;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   return  next;</span><br><span class="line">    &#125;</span><br><span class="line">    int  kmp(String s1,String s2)&#123;</span><br><span class="line">        int[] next=setnext(s2);</span><br><span class="line">        int i=0;int j=0;</span><br><span class="line">        while(i&lt;s1.length() &amp;&amp; j&lt;s2.length())</span><br><span class="line">        &#123;</span><br><span class="line">            if(s1.charAt(i)==s2.charAt(j))&#123;</span><br><span class="line">                i++;j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(j!=0)j=next[j];</span><br><span class="line">            else i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(j==s2.length()) return i-j;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
